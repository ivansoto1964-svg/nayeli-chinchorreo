const express = require("express");
const registry = require("../assistants/registry");
const { generateReply, summarizeConversation } = require("../services/llm");
const {
  getHistory,
  addMessage,
  getSummary,
  setSummary
} = require("../services/memory.disk");

const router = express.Router();

// --- Seguridad mÃ­nima por Bearer token ---
function requireApiKey(req, res, next) {
  const expected = process.env.IVAMAR_API_KEY;
  if (!expected) {
    return res
      .status(500)
      .json({ error: "Server misconfigured: IVAMAR_API_KEY no estÃ¡ seteada" });
  }

  const auth = req.headers.authorization || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7) : null;

  if (!token || token !== expected) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  next();
}

// --- helper: timeout para promesas ---
function withTimeout(promise, ms, label = "Operation") {
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => {
      const err = new Error(`${label} timed out after ${ms}ms`);
      err.code = "TIMEOUT";
      reject(err);
    }, ms);

    promise
      .then((val) => {
        clearTimeout(t);
        resolve(val);
      })
      .catch((err) => {
        clearTimeout(t);
        reject(err);
      });
  });
}

// ðŸ”Ž DEBUG (solo desarrollo): ver memoria y summary
router.get("/debug/memory", requireApiKey, (req, res) => {
  // Solo permitir si DEBUG estÃ¡ activo
  if (process.env.DEBUG_MEMORY !== "true") {
    return res.status(404).json({ error: "Not found" });
  }

  const sid =
    req.query.sessionId && String(req.query.sessionId).trim()
      ? String(req.query.sessionId).trim()
      : "default";

  const history = getHistory(sid) || [];
  const summary = getSummary(sid);

  return res.json({
    sessionId: sid,
    summary,
    historyCount: history.length,
    historyTail: history.slice(-6),
  });
});

// --- Chat endpoint ---
router.post("/chat", requireApiKey, async (req, res) => {
  const { assistantId, message, sessionId } = req.body || {};

  if (!assistantId || !message) {
    return res.status(400).json({
      error: "Debes enviar assistantId y message en el body (JSON)",
    });
  }

  const assistant = registry[assistantId];
  if (!assistant) {
    return res.status(404).json({
      error: `Assistant "${assistantId}" no existe`,
    });
  }

  const sid =
    sessionId && String(sessionId).trim()
      ? String(sessionId).trim()
      : `sid_${Date.now()}`;

  const TIMEOUT_MS = Number(process.env.OPENAI_TIMEOUT_MS || 20000);
  const MAX_MESSAGES = Number(process.env.MEMORY_MAX_MESSAGES || 10);
  const KEEP_RECENT = Number(process.env.MEMORY_KEEP_RECENT || 4);

  // Historial y summary actuales
  const history = getHistory(sid) || [];
  const summary = getSummary(sid);

  // Messages para el LLM (incluye summary si existe)
  const messages = [
    { role: "system", content: assistant.systemPrompt || "" },
    ...(summary
      ? [{ role: "system", content: `Conversation summary: ${summary}` }]
      : []),
    ...history,
    { role: "user", content: String(message) },
  ];

  // Guardar mensaje del usuario
  addMessage(sid, "user", String(message));

  try {
    const reply = await withTimeout(
      generateReply({
        model: assistant.model || "gpt-4o-mini",
        messages,
      }),
      TIMEOUT_MS,
      "OpenAI"
    );

    addMessage(sid, "assistant", reply);

    // âœ… AUTO-SUMMARY
    const liveHistory = getHistory(sid) || [];
    if (liveHistory.length >= MAX_MESSAGES) {
      const existing = getSummary(sid);

      const summaryInput = [
        ...(existing
          ? [{ role: "system", content: `Existing summary: ${existing}` }]
          : []),
        ...liveHistory,
      ];

      try {
        const newSummary = await withTimeout(
          summarizeConversation(summaryInput),
          TIMEOUT_MS,
          "Summarizer"
        );

        if (newSummary && String(newSummary).trim()) {
          setSummary(sid, String(newSummary).trim());
        }

        // Mantener solo los Ãºltimos KEEP_RECENT mensajes en el history
        if (liveHistory.length > KEEP_RECENT) {
          liveHistory.splice(0, liveHistory.length - KEEP_RECENT);
        }
      } catch (e) {
        // si falla el resumen, no rompemos el chat
      }
    }

    return res.json({ reply, sessionId: sid });
  } catch (err) {
    // Timeout â†’ 504
    if (err && err.code === "TIMEOUT") {
      const fallback = assistant.reply
        ? assistant.reply(String(message))
        : "Estoy teniendo demora ahora mismo. Intenta de nuevo en unos segundos.";

      addMessage(sid, "assistant", fallback);

      return res.status(504).json({
        reply: fallback,
        sessionId: sid,
        warning: "OpenAI timeout, served fallback",
      });
    }

    // Otros errores â†’ fallback 200
    const fallback = assistant.reply
      ? assistant.reply(String(message))
      : "Error: assistant sin fallback.";

    addMessage(sid, "assistant", fallback);

    return res.status(200).json({
      reply: fallback,
      sessionId: sid,
      warning: "OpenAI failed, served fallback",
      detail: err && err.message ? err.message : String(err),
    });
  }
});

module.exports = router;

